# Mulholland rewriter | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Mulholland code needs to be rewritten into something runnable in order to be at all useful. This module implements a general-purpose optimizing rewriter for this purpose. It takes as input a
# series of rewrite rules and returns a function that will rewrite a tree accordingly.

caterwaul.module('mulholland.rewrite', 'js_all', function ($) {

# Compile-time rewriting.
# All rewriting rules are localized to a given expression tree in the source; there is no such thing as a toplevel rewrite. You can introduce anonymous rewriting rules as well as using shared
# ones. This is done by using the anonymous-rewriting operator @. So, for example:

# | foo + bar -@ foo /= baz +, bar /= bif
#   foo + bar -@ [foo = bar, bar = bif]           <- same thing, but with explicit grouping

# Compile-time rewrite sections can be nested for abstraction. In this case they apply outside-in. For example:

# | foo + bar -@ [foo = bif + baz, _x + bar = _x -@ [bif = bok]]

# Generating Javascript intrinsics.
# There are more and less creative ways to do this. The simplest is almost certainly to cast a regular word into an operator using a precedence/associativity prefix hint. For example, you can
# generate a for loop like this:

# | (i = 0; i < 10; i ++= 1) -for {stuff}

# You can also generate if/else and other block structures, though they won't have as much structure as they do in Caterwaul. In general, generating block structures isn't that challenging. The
# real problems come in when you want to use unary operators such as 'var' or '++'. To do this, you need to provide an artificial right-hand side that will later be deleted. Mulholland reserves
# the _ symbol for this purpose. For example:

# | x /= 10 -var _ -; _                   -> var x = 10;

# Rewriting optimizations.
# Most of the time Mulholland spends compiling things is taken up by the rewriting process, so a number of optimizations are implemented to make this fast. First, each rule is closed under
# transitivity with each other rule. This means that if x -> y and y -> z, then the rule 'x -> y' is replaced with 'x -> z'. This is quadratic in the number of rules that are present. For
# example, this is a case where transitivity would apply:

# | foo + bif = bar + bif                 <- this would be rewritten as foo + bif = 1 because bar + _x matches bar + bif
#   bar + _x = 1

# Unlike in Caterwaul, rewrites aren't applied recursively to subtrees; each rewrite is strongly contextualized to a specific node. If you wanted to simulate subtree rewriting, you would create
# a rule that explicitly distributes over various types of operators; for instance:

# | @seq _xs@0        = ...                       # base case
#   @seq $ _x /_op _y = @seq _x /_op @seq _y      # binary operator inductive case
#   @seq (_x)         = (@seq _x)                 # transparency over () groups
#   @seq [_x]         = [@seq _x]                 # transparency over [] groups
#   @seq {_x}         = {@seq _x}                 # transparency over {} groups

# Because it's common to want various modes of transparency, Mulholland's standard library provides compile-time rewrite rules to do this for you:

# | @@*-groups $ @seq x
#   @@*-binary $ @seq x

  $.mulholland.rewriter(rules) = rewrite

  -where [current_list        = +rules -seq,

          rewrite_once(t)     = current_list |~![x[1].constructor === Function ? x[1].call(rewrite, x[0] /~match/ t) : x[1] /~replace/ x[0].match(t)] |seq,
          fixed_point(t)      = t *~![x][r = x /!rewrite_once || r] -seq -re- r -where [r = null],
          transitive_limit(r) = [r[0], fixed_point(r[1])],

          uniq(rs)            = rs %!~r[rs |[xi > ri && x[0] /~match/ r[0]]] -seq,
          current_list        = uniq(current_list + current_list *transitive_limit -seq),
          rewrite             = fixed_point]});

# Generated by SDoc 
