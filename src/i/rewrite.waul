# Mulholland rewriter | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Mulholland code needs to be rewritten into something runnable in order to be at all useful. This module implements a general-purpose optimizing rewriter for this purpose. It takes as input a
# series of rewrite rules and returns a function that will rewrite a tree accordingly.

caterwaul.module('mulholland.rewrite', 'js_all', function ($) {

# Compile-time rewriting.
# All rewriting rules are localized to a given expression tree in the source; there is no such thing as a toplevel rewrite. You can introduce anonymous rewriting rules as well as using shared
# ones. This is done by using the anonymous-rewriting operator /@. So, for example:

# | foo + bar /@- foo =/ baz ,+ bar =/ bif
#   foo + bar /@- [foo = bar, bar = bif]           <- same thing, but with explicit grouping

# Compile-time rewrite sections can be nested for abstraction. In this case they apply outside-in. For example:

# | foo + bar /@- [foo = bif + baz, _x + bar = _x /@- [bif = bok]]

# Rewriting optimizations.
# Most of the time Mulholland spends compiling things is taken up by the rewriting process, so a number of optimizations are implemented to make this fast. First, each rule is closed under
# transitivity with each other rule. This means that if x -> y and y -> z, then the rule 'x -> y' is replaced with 'x -> z'. This is quadratic in the number of rules that are present. For
# example, this is a case where transitivity would apply:

# | foo + bif = bar + bif                 <- this would be rewritten as foo + bif = 1 because bar + _x matches bar + bif
#   bar + _x = 1

  $.mulholland.rewriter(rules) = rewrite /-$.merge/ capture [rules = current_list, extend(rs) = $.mulholland.rewriter(current_list + rs -seq)]

  -where [current_list = +rules -seq,
          change       = null,

          pattern_complexity() = current_list /[Infinity][x0 /-Math.min/ x[0].complexity()] -seq,
          rewrite_once(t)      = current_list |~![x[1].constructor === Function ? x[1].call(rewrite, x[0] /~match/ t) : x[1] /~replace/ x[0].match(t)] |seq |se [change = change || it],

          deep_rewriter(c = pattern_complexity())(t)        = t.complexity() >= c ? t /~rmap/ rewrite_once : t,
          fixed_point(r = deep_rewriter(), fix = result)(t) = (change = null, r(t) -re [change ? (console.log(it.structure()), fix(it)) : it]),
          transitive_limit(r)                               = r[1].constructor === Function ? r : [r[0], fixed_point()(r[1])],

          uniq(rs)             = rs %!~r[rs |[xi > ri && x[0] /~match/ r[0]]] -seq,
          current_list         = uniq(current_list + current_list *transitive_limit -seq),
          rewrite              = fixed_point()]});

# Generated by SDoc 
