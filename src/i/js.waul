# Mulholland -> Javascript bindings | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Mulholland is ultimately compiled down to Javascript. For various reasons, primarily optimization, it's important that this bottom layer provide lots of control about how to represent things.
# For instance, there are several different ways to encode closures and continuations in Javascript, and some are faster (and more memory-efficient) than others. I'm leaving the decision about
# which one to use up to other higher-level rewriting rules.

caterwaul.module('mulholland.js', 'js_all', function ($) {

# Implementation.
# Mulholland can generate most of Javascript's important constructs. Some are left out because they can be encoded in other ways. Importantly, Mulholland has first-class representations of
# Javascript's imperative features, unlike Caterwaul. This allows you to compose more efficient functions by eliminating closure GC and function call overhead. The Javascript constructs
# supported by this library are:

# | 1. Conditionals using if/else (no switch)
#   2. Loops using for and while
#   3. Variable addressing and automatic naming (local, closure-scoped, property accesses, this, arguments)
#   4. Function values (no declarative-mode function definitions; the syntax for this is a hideous abomination)
#   5. Expression-mode operators

# Here are some examples of Mulholland trees and their conversions into Javascript:

# | then-part /if cond /else else-part            -> if (cond) {then-part} else {else-part}
#   then-part /if cond                            -> if (cond) {then-part}
#   body /while cond                              -> while (cond) {body}
#   body /for [init; cond; inc]                   -> for (init; cond; inc) {body}
#   body /rescue x                                -> try {body} catch (e) {x}
#   v /var value                                  -> var v = value
#   (x, y, z) -> body                             -> function (x, y, z) {return body}
#   s1 ; s2 ; s3                                  -> s1 ; s2 ; s3

# Returning values this way is inconvenient, so Mulholland's implementation of return distributes over several control-flow constructs:

# | return (s1 ; s2)                              -> s1 ; return s2
#   return (x /if cond)                           -> if (cond) {return x}
#   return (x /if cond /else y)                   -> if (cond) {return x} else {return y}
#   return (x /rescue y)                          -> try {return x} catch (e) {return y}
#   return (v /var value)                         -> var v = value ; return v             // It's important to do it this way instead of 'return value'; self-referential closure.

  $.mulholland.js(parser, convert = result) = "rewrite(_) -re- it /!as_javascript".qf

  -where [rules                     = [['return (_s1 ; _s2)',                                '_s1 ; return _s2'],  ['return (_x /if _cond)',          'return _x /if _cond'],
                                       ['return (_x /if _cond /else _y)', 'return _x /if _cond /else return _y'],  ['return (_x /rescue _y)', 'return _x /rescue return _y'],
                                       ['return (_v@0 /var _value)',                '_v /var _value; return _v']]

                                      *~[x *parser] -seq,

          expand_match_parts(match) = match %k%[x.length > 1] %v*as_javascript -seq,
          primitives                = [['_body /if _cond',                  'if (_cond) {_body}'.qs],  ['_body /if _cond /else _else',      'if (_cond) {_body} else {_else}'.qs],
                                       ['_body /while _cond',            'while (_cond) {_body}'.qs],  ['_body /for [_init; _cond; _inc]', 'for (_init; _cond; _inc) {_body}'.qs],
                                       ['_body /rescue _catch', 'try {_body} catch (e) {_catch}'.qs],  ['_v@0 /var _value',                                 'var _v = _value'.qs],
                                       ['_xs -> _body',                 'function (_xs) {_body}'.qs],  ['_x ; _y',                                                  '_x ; _y'.qs],
                                       ['_x [_y]',                                      '_x[_y]'.qs],  ['_f _x',                                                     '_f(_x)'.qs]]

                                      *+[[parser(x[0]), "_ && x[1].replace(_ /!expand_match_parts)".qf]] -seq,

          as_javascript(t)          = primitives |[x[1](x[0] /~match/ t)] |seq || new caterwaul.syntax(t.resolved_data(), +t *as_javascript -seq),
          rewrite                   = $.mulholland.rewriter(rules)]});

# Generated by SDoc 
