# Javascript <-> Mulholland interface | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Mulholland is bidirectionally convertible to Javascript through Caterwaul source tree construction. This module provides a way to convert Caterwaul trees into Mulholland trees and back; this
# is useful for doing declarative rewrites on Javascript faster than Caterwaul would be able to do them. The basic mechanism is that we just prepend a / to each Javascript node type. Literals
# are transcribed directly, with the exception of things that start with $ (these are converted into @$). This transformation is invertible using the as_js() method of Mulholland source trees.

# There are some conversion rules used to help Mulholland and Caterwaul interoperate. They are:

# | 1. (# (_f) (_x))              <-> (() (_f) (_x))
#   2. (/@b (_f) (_x))            <-> ([] (_f) (_x))
#   3. (/@p! (_x))                <-> (( (_x))
#   4. (_op (_x) (/@: (_y) (_z))) <-> (_op (_x) (_y) (_z))        <- binary/ternary conversion
#   5. (@$_stuff)                 <-> ($_stuff)                   <- conversion of $ in an operator position
#   6. ("/_string/_mods"r)        <-> (/_string/_mods)

# It should be noted that this library doesn't make Caterwaul interfacing easy; it makes it possible. The standard library builds better abstractions on top of this.

caterwaul.module('mulholland.jsi', 'js_all', function ($) {
  $ /~syntax_extend/ {as_mh: as_mh},
  $.mulholland.syntax_common.as_js = as_js,

  where [as_mh(p) = this.data === '()' ? new p.syntax('#'   /!p.intern, [this[0].as_mh(p), this[1].data.length ? this[1].as_mh(p) : new p.syntax('@' /!p.intern)]) :
                    this.data === '[]' ? new p.syntax('/@b' /!p.intern, [this[0].as_mh(p), this[1].data.length ? this[1].as_mh(p) : new p.syntax('@' /!p.intern)]) :
                    this.data === '('  ? new p.syntax('/@p' /!p.intern, [new p.syntax('_' /!p.intern), this[0].as_mh(p)]) :
                    this.length === 0  ? new p.syntax(this.data /!mh_encode_literal /!p.intern) :
                    this.length === 3  ? new p.syntax(this.data /!mh_encode         /!p.intern, [this[0].as_mh(p), new p.syntax('/@:' /!p.intern, [this[1].as_mh(p), this[2].as_mh(p)])]) :
                                         new p.syntax(this.data /!mh_encode         /!p.intern, [this[0].as_mh(p), this[1].as_mh(p)]),

         as_js()  = this.resolved_data() === '#'                           ? new $.syntax('()', this[0].as_js(), this[1].resolved_data() === '@' ? $.empty : this[1].as_js()) :
                    this.resolved_data() === '/@b'                         ? new $.syntax('[]', this[0].as_js(), this[1].resolved_data() === '@' ? $.empty : this[1].as_js()) :
                    this.resolved_data() === '/@p!'                        ? new $.syntax('(',  this[0].as_js()) :
                    this.length === 2 && this[1].resolved_data() === '/@:' ? new $.syntax(this.resolved_data() /!mh_decode, [this[0].as_js(), this[1][0].as_js(), this[1][1].as_js()]) :
                    this.length === 0                                      ? new $.syntax(this.resolved_data() /!mh_decode_literal) :
                                                                             new $.syntax(this.resolved_data() /!mh_decode, +this %~![x.resolved_data() !== '@' && x.as_js()] -seq),

         mh_encode_literal(s) = /\/./.test(s) ? '"' + s.replace(/"/g, '\\"') + '"r' : s.replace(/^\$/, '@$'),
         mh_encode(s)         = /^[()\[\]{}\.,;:]/.test(s) ? s : '/' + s,

         mh_decode_literal(s) = /^".*"r$/.test(s) ? '/' + s.replace(/\\"/g, '"').replace(/"r$/, '') : s.replace(/^@\$/, '$'),
         mh_decode(s)         = s.replace(/^\//, '')]});

# Generated by SDoc 
