# Mulholland parser | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The parser is based on operator-precedence parsing using a regexp lexer. This should be very fast under recent Javascript VMs and should involve a minimal GC overhead. Symbols are interned
# into integers to accelerate access; the tree can be back-translated by dereferencing: tree.resolved_data(). This interning process is done before folding groups. Assigned numbers are coded
# according to their syntactic roles.

# Unlike the Caterwaul parser, this one uses a shunting yard algorithm to fold operators as the parse is running. We can get away with this because there are no special cases involving blocks
# and there are no patch-ups that need to be done. The algorithm is modified from the original shunting-yard algorithm in that it detects operator-value / value-value sequences so that it can
# parse implicit joins (e.g. f x = x + 1: in this case, 'f x' is an implicit join with high precedence).

caterwaul.module('mulholland.parser', 'js_all', function ($) {
  $.mulholland.parser(table = {}, table_i = {}, next = 0) = parser /-$.merge/ statics()

# Static data.
# You can access most of the internal state of a parser. You probably shouldn't poke around and change stuff, but you can at the very least inspect it and ask the parser questions. (For
# instance, you might want to know the precedence and associativity of a given operator.)

  -where [parser    = "_.toString() /!sdoc /!lex /!parse".qf,
          syntax    = $.mulholland.syntax(parser),
          statics() = capture [syntax = syntax, intern = intern, extern = extern, lex = lex, sdoc = sdoc],

# Lexer and token types.
# Tokens are lexed independently of their position in the input stream. This can be done because Mulholland doesn't have lex-ambiguous tokens like Javascript's regular expressions. At a high
# level, Mulholland supports these types of tokens:

# | 1. Identifiers, which have the form /[_@A-Za-z0-9\x7f-\uffff][^ \n\t\r.:,;()\[\]{}]*/
#   2. Strings with \ escapes and optional identifier suffixes of the form /[^ \n\t\r.:,;()\[\]{}]*/
#   3. Line comments that start with # and go until the next newline (these are, of course, removed from the token stream)
#   4. Brackets, which are any of [ ] ( ) { }
#   5. Operators, which are of the form /[^ \n\t\r()\[\]{}]+/ and are not identifiers
#   6. Micro-operators, which are of the form /[.:,;][^ \n\t\rA-Za-z0-9@]*/

# It also supports SDoc-style paragraph comments. These are removed just like line comments. Mulholland treats all whitespace and comments as a single space. It is Unicode-capable but naively
# treats any Unicode character as the beginning of an identifier.

          sdoc(s) = s.split(/\n(?:\s*\n)+/) %![/^\s*[A-Z|]/.test(x)] -seq -re- it.join(' '),
          lexer   = /(#.*|(?:[_@\w\d\x7f-\uffff]|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")[^ \n\t\r.:,;()\[\]{}]*|[^ \n\t\r.:,;()\[\]{}][^ \n\t\r()\[\]{}]*|[()\[\]{}]|[.:,;][^ \n\t\r\d\w@]*)/,
          lex(s)  = s.split(lexer) %[/^[^ \n\t\r#]/.test(x)] -seq,

# Symbol interning.
# Symbols are interned into integers for performance reasons. The overhead involved in doing this is relatively small and the speedup for rewrites is quite significant. These symbols are
# transparently rendered by the syntax nodes, whose constructor is already parameterized with the symbol table. Note, however, that this means you need to use the same parser for all trees that
# are backed by symbol tables, at least until you render them into regular Caterwaul syntax trees. On the bright side, the syntax node constructor contains a reference to the parser that created
# it; so generally speaking you don't have to worry about it.

          intern(s) = Object.prototype.hasOwnProperty.call(table_i, s) ? table_i[s] : table_i[table[next] = s] = next++,
          extern(n) = Object.prototype.hasOwnProperty.call(table, n)   ? table[n]   : n,

# Operator precedence and associativity.
# Mulholland relies heavily on operators not only for semantic hints, but also to determine tree structure. To make it efficient to deal with these cases, Mulholland gives you a strange and
# irregular syntax to get stuff done quickly. Like many aspects of the language, it is highly motivated by QWERTY keyboard ergonomics.

# Operator structure.
# The following characters are erased and used as precedence/associativity hint (listed by descending precedence): / - \ = |. A mnemonic is that they are all comprised entirely of
# nonintersecting straight lines. For example, foo /bar/ bif /baz folds into (baz (bar/ foo bif)). On the other hand, foo / bar does what you'd expect: (/ foo bar). There are some situations
# where these rules don't apply. For example, any repeated character is not erased: // is rendered as //, not erased into /. The rationale for this is that there would be no point to modifying
# an operator with itself. This stops applying when you have longer operators: //- becomes /-.

# Sometimes you want to write a series of unary operators (or modifiers, or some such). To do this, use a splitter as the first non-erased character of the operator: * + ^ < >. For example, you
# can emulate the Caterwaul sequence library syntax: foo *~!bar[bif] -seq, which parses out to (seq (* foo (~ (! (bar ([ bif)))))). The mnemonic for these is that they are all rendered as
# intersecting straight lines. Splitters do not apply to themselves; for instance, ** is preserved, not converted into (* (* ...)).

# Micro-ops are separate from identifiers that precede and follow them. For instance, foo.bar is parsed as (. foo bar). However, you can suffix a micro-op with more operator characters: foo.+bar
# -> (.+ foo bar). Micro-ops have unmodifiable precedence, arity, and associativity. Note that you can use micro-ops inside other operators; in this context they no longer have micro-op
# behavior: foo /.bif bar -> (.bif foo bar).

# The special operator $, when used as a prefix, is used to decrease the precedence of something and make it right-associative. When used alone, it is rewritten as an applicative node (#). $ in
# a prefix position is always erased. (Elsewhere it is preserved.) For example:

# | f $ g y       -> (# f (# g y))
#   f $ g $ h x   -> (# f (# g (# h x)))
#   f $ g x $$ y  -> (# (f (# g x)) y)

# | f $% g + x    -> (% f (+ g x))
#   f $% g < x    -> (< (% f g) x)
#   f $$% g < x   -> (% f (< g x))
#   f $$% g = x   -> (= (f % g) x)
#   f $$$% g = x  -> (% f (= g x))
#   f $% g /= x   -> (% f (= g x))        <- this is probably a better way to do it

# All remaining operator characters, ! ` ~ &, are interpreted normally. For instance, foo &/x bar -> (&/x foo bar).

          operator_lexer          = /^(\$*)([-\/\\|=]?)(.+)$/.qf,
          operator_splitter       = /^[+*^<>]/.qf,
          operator_split_lexer    = /\W|[\w\d\x7f-\uffff]+/,
          precedence_table        = '\\. # [`~!] [/*%] [-+] [\\\\:] [<>] & [|^] [=?] , ; [(\[{]'.qw *[new RegExp('^#{x}')] -seq,
          right_associative       = /^[`~!\\\\:=?]/.qf,
          unary                   = /^[~!A-Za-z0-9]/.qf,
          is_value                = /^['"_@A-Za-z0-9\x7f-\uffff]/.qf,
          base_precedence(t)      = precedence_table |[x.test(t) && xi + 1] |seq,
          is_closer(t)            = t === '?:' ? 12 : ')]}' /~indexOf/ t + 13,
          is_opener(t)            = /^\?/.test(t) ? 8 : '([{' /~indexOf/ t + 9,

          destructure(t)          = t /!is_value ? {f: 0, p: 0, id: t /!intern} : t /!destructure_operator,
          destructure_operator(t) = {f: base /!is_opener || base /!is_closer || right_associative(base) | unary(base) << 1, p: adjustment + base /!base_precedence, id: canonical /!intern}
                            -where [pieces     = operator_lexer(t),      base      = pieces[2] || pieces[3],
                                    adjustment = pieces[1].length << 2,  canonical = pieces[2] === pieces[3] ? pieces[2] + pieces[3] : pieces[3]],

# Shunting yard implementation.
# Most of the implementation here is the classical shunting yard algorithm. The only real point of divergence is that it maintains a flag that indicates whether a value should be interpreted as
# an operand or whether a join should be inserted. For example, in the expression 'f.x y', an implicit join is inserted to form (# (. f x) y). Ternary operators are handled in two pieces. The
# left-hand side is evaluated normally, but the opener remains on the operator stack. The closer then causes everything back to the opener to be grouped into a ternary node, and the opener
# remains on the stack. At this point there are two spare values on the value-stack and the opener on the operator stack. Finally, something will cause the operator stack to be forced; when a
# ternary is forced, it collects three values instead of two.

          parse(ts)               = ts *destructure *!observe -seq -re- apply_all()
                            -where [expect_value        = true,
                                    values              = [],
                                    operators           = [],
                                    top()               = operators[operators.length - 1],

                                    join                = '#' /!destructure,

                                    apply_unary()       = values /~push/ new syntax(operators.pop().id, [x])       -where [x = values.pop()],
                                    apply_binary()      = values /~push/ new syntax(operators.pop().id, [y, x])    -where [x = values.pop(), y = values.pop()],
                                    apply_ternary()     = values /~push/ new syntax(operators.pop().id, [z, y, x]) -where [x = values.pop(), y = values.pop(), z = values.pop()],
                                    apply(v = top().f)  = v === 24 ? apply_ternary() : v & 2 ? apply_unary() : apply_binary(),
                                    apply_until(f)      = null *~![operators.length && !f(top())][apply()] -seq,

                                    apply_operator(t)   = apply_until(t.f & 1 ? "_.f & 8 || _.r >= t.p".qf : "_.f & 8 || _.p > t.p".qf),

                                    maybe_join()        = observe_op(join) /when [expect_value === (expect_value = false)],

                                    observe(t)          = t.f ? observe_operator(t) : observe_value(t),
                                    observe_value(t)    = maybe_join() -then- values /~push/ new syntax(t.id),
                                    observe_operator(t) = t.f & 8 ? t.f & 4 ? observe_closer(t) : observe_opener(t) : t.f & 2 ? observe_vop(t) : observe_op(t),
                                    observe_opener(t)   = t.f === 8 ? observe_op(t) : observe_vop(t),
                                    observe_closer(t)   = t.f === 12 ? close_ternary(t) : apply_until(opener) -then [expect_value = false] -then- apply_unary(),

                                    observe_vop(t)      = maybe_join() -then- observe_op(t),
                                    observe_op(t)       = apply_operator(t) -then- operators /~push/ t -then [expect_value = true],

                                    close_ternary(t)    = apply_until(opens_ternary) -then [expect_value = true, top().f |= 16],

                                    opens_ternary(t)    = t.f === 8,
                                    opener(t, f = t.f)  = f & 8 && !(f & 4),

                                    apply_all()         = apply_until("false".qf) -then- values[0]]]});

# Generated by SDoc 
