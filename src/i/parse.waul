# Mulholland parser | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The parser is based on operator-precedence parsing using a regexp lexer. This should be very fast under recent Javascript VMs and should involve a minimal GC overhead. Symbols are interned
# into integers to accelerate access; the tree can be back-translated by dereferencing: tree.resolved_data(). This interning process is done before folding groups. Assigned numbers are coded
# according to their syntactic roles.

# Unlike the Caterwaul parser, this one uses a shunting yard algorithm to fold operators as the parse is running. We can get away with this because there are no special cases involving blocks
# and there are no patch-ups that need to be done. The algorithm is modified from the original shunting-yard algorithm in that it detects operator-value / value-value sequences so that it can
# parse implicit joins (e.g. f x = x + 1: in this case, 'f x' is an implicit join with high precedence).

caterwaul.module('mulholland.parser', 'js_all', function ($) {
  $.mulholland.parser(table = {}, table_i = {}, next = 0) = parser /-$.merge/ statics()

# Static data.
# You can access most of the internal state of a parser. You probably shouldn't poke around and change stuff, but you can at the very least inspect it and ask the parser questions. (For
# instance, you might want to know the precedence and associativity of a given operator.)

  -where [parser    = "_.toString() /!sdoc /!lex /!parse".qf,
          syntax    = $.mulholland.syntax(parser),
          statics() = capture [syntax = syntax, intern = intern, extern = extern, lex = lex, sdoc = sdoc],

# Lexer and token types.
# Tokens are lexed independently of their position in the input stream. This can be done because Mulholland doesn't have lex-ambiguous tokens like Javascript's regular expressions. At a high
# level, Mulholland supports these types of tokens:

# | 1. Identifiers, which have the form /[_@A-Za-z0-9\x7f-\uffff][^ \n\t\r.:,;()\[\]{}]*/
#   2. Strings with \ escapes and optional identifier suffixes of the form /[^ \n\t\r.:,;()\[\]{}]*/
#   3. Line comments that start with # and go until the next newline (these are, of course, removed from the token stream)
#   4. Brackets, which are any of [ ] ( ) { }
#   5. Operators, which are of the form /[^ \n\t\r()\[\]{}]+/ and are not identifiers
#   6. Micro-operators, which are of the form /[.:,;][^ \n\t\rA-Za-z0-9@]*/

# It also supports SDoc-style paragraph comments. These are removed just like line comments. Mulholland treats all whitespace and comments as a single space. It is Unicode-capable but naively
# treats any Unicode character as the beginning of an identifier.

          sdoc(s) = s.split(/\n(?:\s*\n)+/) %![/^\s*[A-Z|]/.test(x)] -seq -re- it.join(' '),
          lexer   = /(#.*|(?:[_@\w\d\x7f-\uffff]|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")[^ \n\t\r.:,;()\[\]{}]*|[^ \n\t\r.:,;()\[\]{}][^ \n\t\r()\[\]{}]*|[()\[\]{}]|[.:,;][^ \n\t\r\d\w@]*)/,
          lex(s)  = s.split(lexer) %[/^[^ \n\t\r#]/.test(x)] -seq,

# Symbol interning.
# Symbols are interned into integers for performance reasons. The overhead involved in doing this is relatively small and the speedup for rewrites is quite significant. These symbols are
# transparently rendered by the syntax nodes, whose constructor is already parameterized with the symbol table. Note, however, that this means you need to use the same parser for all trees that
# are backed by symbol tables, at least until you render them into regular Caterwaul syntax trees. On the bright side, the syntax node constructor contains a reference to the parser that created
# it; so generally speaking you don't have to worry about it.

          intern(s) = Object.prototype.hasOwnProperty.call(table_i, s) ? table_i[s] : table_i[table[next] = s] = next++,
          extern(n) = Object.prototype.hasOwnProperty.call(table, n)   ? table[n]   : n,

# Asymmetric operator precedence.
# Mulholland goes off the deep end with operator precedence stuff by allowing operators to have asymmetric precedence and associativity. For example, you can say things like 3 +/ 4 / 5, which
# folds into (/ (+/ 3 4) 5) instead of the usual (+/ 3 (/ 4 5)). It's probably easier to think about precedence asymmetry as a generalization of what happens with parentheses. For instance, the
# open parenthesis from the left has very high precedence, but from the right has very low precedence:

# | x * (foo = bar)       <- * waits for close-paren, = folds before close-paren

# Here, open-parenthesis is unary because it appears where we expect a value. But the same generalization is possible for binary operators. The precedence modification is defined in terms of
# shunting yard mechanics:

# | 3 +/ 4 / 5    -> encounter +/, push onto op stack
#                 -> encounter /, force +/ because its right-precedence is equal and / left-associates

# Determining operator behavior.
# In addition to having an unusual way of dealing with operators, Mulholland gives you the ability to alter their precedence and associativity from each side without changing their semantic
# characteristics. These are, at a high level, the rules it follows:

# | 1. Operators that begin with an operator character bind values to their left; those that end with an operator bind values to their right. Most operators are binary, as they do both.
#   2. The following characters on the beginning or end of an operator modify its directional precedence/associativity (from high to low precedence): / - \ = |.
#   3. Operators that begin with $ have both directional precedences decreased by the same amount. This character is erased and can occur multiple times.

# Erasure.
# When you write an operator, some of the characters exist only to change its left/right precedence/associativity. These characters are useful only to provide tree structure and shouldn't be
# included in the parsed output. For example:

# | 3 $+ 4 + 5    -> (+ 3 (+ 4 5))                        x //- y / z  -> (//- x (/ y z))
#   x //.- y / z  -> (// x (/ y z))                       x -// y / z  -> (/ (// x y) z)
#   x --/ y / z   -> (/ (--/ x y) z)                      x /*%!!      -> (/*%!! x)
#   x / y /*++!   -> (/*++! (/ x y))                      x /~         -> (~ x)
#   x / y /*++ z  -> (/*++ (/ x y) z)

# Mulholland uses several heuristics to determine whether a potential hint can be erased:

# | 1. If a hint appears on the left-side of an operator and is followed by a character of different precedence or associativity, it is erased.
#   2. If a hint appears on the right-side of an operator and is prefixed with a dot, it and the dot are erased.
#   3. All prefix $ characters are always erased. If the operator consisted entirely of $, it becomes a join (#).

# Hints are used even if they aren't erased. For example:

# | /--   no erasure; left precedence is /, right precedence is -
#   //-   partial erasure; left precedence is /, right precedence is -
#   ///   partial erasure; left and right precedence are both /
#   ***   no erasure; left and right precedence are both *, which is the same as /
#   ***.- partial erasure; left precedence is *, right precedence is -
#   /+    partial erasure; left precedence is /, right precedence is +, which is the same as -

# Precedence groups.
# Mulholland uses a fairly normal precedence layout. From high to low precedence, these are the classes of operators it supports and their associativity:

# | . #           left
#   ! ~           right (unary)
#   / *           left
#   % `           right
#   + -           left
#   \ :           right
#   < >           left
#   & ?           right
#   ^             left
#   =             right
#   |             left
#   ,             right
#   ;             left
#   ( [ {         right (asymmetric precedence)
#   ) ] }         left  (asymmetric precedence)

# The $ character shifts an operator two levels down in this stack. This is really important; combined with the associativity alternation, it means that no associativity collisions will be
# created. (Imagine the problem: x $+ y + z or some such, where $+ has the same precedence as a right-associative operator.)

          precedence_table          = '[#\\.] [~!] [/*] [%`] [+-] [\\\\:] [<>] [&?] \\^ = \\| , ;'.qw *[new RegExp('^#{x}')] -seq,
          base_precedence(t)        = precedence_table |[x.test(t) && xi + 2] |seq,
          operator_lexer            = /^(\$*)([-\/\\|=]?)(.+?)(\.[-\/\\|=])?$/.qf,
          is_value                  = /^["'A-Za-z0-9@_\xff-\uffff]/.qf,

          parse_token(t)            = is_value(t) ? {l: 0, r: 0, u: 0, v: t /!is_value, id: t /!intern} : parse_operator(t),

          parse_operator(t)         = '([{'.indexOf(t) !== -1 ? {l: 0,       r: 1 << 30 | 1, id: t /!intern, v: false, u: true} :
                                      ')]}'.indexOf(t) !== -1 ? {l: 1 << 30, r: 0,           id: t /!intern, v: false, u: true} : parse_regular_operator(t),

          parse_regular_operator(t) = {l: left, r: right, id: canonical /!intern, v: false, u: right === adjust}
                              -where [pieces    = operator_lexer(t),
                                      adjust    = pieces[1].length << 1,
                                      canonical = pieces[3] || '#',
                                      left      = adjust + pieces[2]                            /!base_precedence /or [canonical /!base_precedence],
                                      right     = adjust + pieces[4] /and [pieces[4].charAt(1)] /!base_precedence /or [canonical.charAt(canonical.length - 1) /!base_precedence]],

          parse(ts)                 = ts *parse_token *!observe -seq -re- apply_all()
                              -where [values        = [],
                                      operators     = [],
                                      ev            = true,
                                      top()         = operators[operators.length - 1],
                                      precedence(n) = apply() -then- precedence(n) -when [operators.length && (n & 1 ? top().r < n : top().r <= n)],
                                      observe(t)    = t.v ? observe('#') /when [ev === (ev = false)] -then- values /~push/ new syntax(t.id)
                                                          : precedence(t.l) -then- operators /~push/ t -then [ev |= !t.u],

                                      apply()       = top().u ? values /~push/ new syntax(operators.pop().id, [values.pop()])
                                                              : values /~push/ new syntax(operators.pop().id, [y, x]) /where [x = values.pop(), y = values.pop()],
                                      apply_all()   = operators.length ? apply() -then- apply_all() : values[values.length - 1]]]});

# Generated by SDoc 
