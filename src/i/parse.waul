# Mulholland parser | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The parser is based on operator-precedence parsing using a regexp lexer. This should be very fast under recent Javascript VMs and should involve a minimal GC overhead. Symbols are interned
# into integers to accelerate access; the tree can be back-translated by dereferencing: tree.resolved_data(). This interning process is done before folding groups. Assigned numbers are coded
# according to their syntactic roles.

# Unlike the Caterwaul parser, this one uses a shunting yard algorithm to fold operators as the parse is running. We can get away with this because there are no special cases involving blocks
# and there are no patch-ups that need to be done. The algorithm is modified from the original shunting-yard algorithm in that it detects operator-value / value-value sequences so that it can
# parse implicit joins (e.g. f x = x + 1: in this case, 'f x' is an implicit join with high precedence).

caterwaul.module('mulholland.parser', 'js_all', function ($) {
  $.mulholland.parser(table = {}, table_i = {}, next = 0) = parser /-$.merge/ statics()

# Static data.
# You can access most of the internal state of a parser. You probably shouldn't poke around and change stuff, but you can at the very least inspect it and ask the parser questions. (For
# instance, you might want to know the precedence and associativity of a given operator.)

  -where [parser    = "_.toString() /!sdoc /!lex /!parse".qf,
          syntax    = $.mulholland.syntax(parser),
          statics() = capture [syntax = syntax, intern = intern, extern = extern, transient_intern = transient_intern, lex = lex, sdoc = sdoc, parse_token = parse_token],

# Lexer and token types.
# Tokens are lexed independently of their position in the input stream. This can be done because Mulholland doesn't have lex-ambiguous tokens like Javascript's regular expressions. At a high
# level, Mulholland supports these types of tokens:

# | 1. Identifiers, which have the form /[_@A-Za-z0-9\x7f-\uffff][^ \n\t\r.:,;()\[\]{}]*/
#   2. Strings with \ escapes and optional identifier suffixes of the form /[^ \n\t\r.:,;()\[\]{}]*/
#   3. Line comments that start with # and go until the next newline (these are, of course, removed from the token stream)
#   4. Operators, which are of the form /[^ \n\t\r()\[\]{}]+/ and are not identifiers
#   5. Micro-operators, which are of the form /[.:,;][^ \n\t\rA-Za-z@_()\[\]{}]*/
#   6. Grouping operators, which are of one of ( ) [ ] { }. Of these, parentheses are erased.

# It also supports SDoc-style paragraph comments. These are removed just like line comments. Mulholland treats all whitespace and comments as a single space. It is Unicode-capable but naively
# treats any Unicode character as the beginning of an identifier.

          sdoc(s) = s.split(/\n(?:\s*\n)+/) %![/^\s*[A-Z|]/.test(x)] -seq -re- it.join(' '),
          lexer   = /(#.*|(?:[@\w\x7f-\uffff]|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")[^\s.:,;()\[\]{}]*|[.:,;][^\sA-Za-z@_()\[\]{}]*|[^\s.;,;()\[\]{}][^\s()\[\]{}]*|[()\[\]{}])/,
          lex(s)  = s.split(lexer) %[/^[^ \n\t\r#]/.test(x)] -seq,

# Symbol interning.
# Symbols are interned into integers for performance reasons. The overhead involved in doing this is relatively small and the speedup for rewrites is quite significant. These symbols are
# transparently rendered by the syntax nodes, whose constructor is already parameterized with the symbol table. Note, however, that this means you need to use the same parser for all trees that
# are backed by symbol tables, at least until you render them into regular Caterwaul syntax trees. On the bright side, the syntax node constructor contains a reference to the parser that created
# it; so generally speaking you don't have to worry about it.

          intern(s) = Object.prototype.hasOwnProperty.call(table_i, s) ? table_i[s] : table_i[table[next] = s] = next++,
          extern(n) = n.constructor === Number && Object.prototype.hasOwnProperty.call(table, n) ? table[n] : n,

          transient_intern(s) = Object.prototype.hasOwnProperty.call(table_i, s) ? table_i[s] : s.toString(),

# Asymmetric operator precedence.
# Mulholland goes off the deep end with operator precedence stuff by allowing operators to have asymmetric precedence and associativity. For example, you can say things like 3 +/ 4 / 5, which
# folds into (/ (+/ 3 4) 5) instead of the usual (+/ 3 (/ 4 5)). It's probably easier to think about precedence asymmetry as a generalization of what happens with parentheses. For instance, the
# open parenthesis from the left has very high precedence, but from the right has very low precedence (in most languages; Mulholland uses them for something totally different):

# | x * (foo = bar)       <- * waits for close-paren, = folds before close-paren

# Here, open-parenthesis is unary because it appears where we expect a value. But the same generalization is possible for binary operators. The precedence modification is defined in terms of
# shunting yard mechanics:

# | 3 +/ 4 / 5    -> encounter +/, push onto op stack
#                 -> encounter /, force +/ because its right-precedence is equal and / left-associates

# Determining operator behavior.
# In addition to having an unusual way of dealing with operators, Mulholland gives you the ability to alter their precedence and associativity from each side without changing their semantic
# characteristics. These are, at a high level, the rules it follows:

# | 1. Operators that begin with an operator character bind values to their left; those that end with an operator bind values to their right. Most operators are binary, as they do both.
#   2. The following characters on the beginning or end of an operator modify its directional precedence/associativity (from high to low precedence): / - \ = |.
#   3. Operators that begin with $ have both directional precedences decreased by the same amount. This character is erased and can occur multiple times.

# Erasure.
# When you write an operator, some of the characters exist only to change its left/right precedence/associativity. These characters are useful only to provide tree structure and shouldn't be
# included in the parsed output. For example:

# | 3 $+ 4 + 5    -> (+ 3 (+ 4 5))                        x //- y / z  -> (//- x (/ y z))
#   x //- y / z   -> (// x (/ y z))                       x -// y / z  -> (/ (// x y) z)
#   x --/ y / z   -> (/ (--/ x y) z)                      x /*%!!      -> (/*%!! x)
#   x / y /*++!   -> (/*++! (/ x y))                      x /~         -> (~ x)
#   x / y /*++ z  -> (/*++ (/ x y) z)

# Mulholland uses several heuristics to determine whether a potential hint can be erased:

# | 1. If a hint appears on the left-side of an operator, it is erased.
#   2. All prefix $ characters are always erased. If the operator consisted entirely of $, it becomes a join (#).

# Hints are used even if they aren't erased. For example:

# | /--   partial erasure; left precedence is /, right precedence is -
#   //-   partial erasure; left precedence is /, right precedence is -
#   ///   partial erasure; left and right precedence are both /
#   ***   no erasure; left and right precedence are both *, which is the same as /
#   ***-  no erasure; left precedence is *, right precedence is -
#   /+    partial erasure; left precedence is /, right precedence is +, which is the same as -

# Precedence groups.
# Mulholland uses a fairly normal precedence layout. From high to low precedence, these are the classes of operators it supports and their associativity:

# | .             left
#   (none)        right
#   #             left
#   ! ~           right (unary)
#   / *           left
#   % `           right
#   + -           left
#   \ :           right
#   < >           left
#   & ?           right
#   ^             left
#   =             right
#   |             left
#   ...
#   ,             right
#   ;             left

# The $ character shifts an operator four levels down in this stack. This is really important; combined with the associativity alternation, it means that no associativity collisions will be
# created. (Imagine the problem: x $+ y + z or some such, where $+ has the same precedence as a right-associative operator.) The only exception to this is that $ right-associates, and this does
# create collisions. In this case, the collision is with + and -.

# Parser internals.
# The first stage involves "parsing" each token into a structure that describes its characteristics. These characteristics are:

# | 1. l  its left-facing precedence (greater is lower precedence)
#   2. r  its right-facing precedence
#   3. id the interned symbol ID of the canonical form of the token (after operator hint erasure; values are preserved verbatim)
#   4. v  truthy if the token is a value
#   5. u  truthy if the token represents a unary operator
#   6. o  truthy if the token opens a group
#   7. c  truthy if the token closes a group
#   8. i  truthy if the token is invisible; that is, it should not be consed into an operator node (this is used to implement parenthesis erasure)

# The values in these structures govern the parser's behavior. For instance, when we encounter an operator, we force the operator stack until the right-facing precedence of the stack top lines
# up with the left-facing precedence of the operator we've just seen. This is a fairly standard feature of shunting-yard operator precedence parsers, though generalized a bit to deal with
# precedence asymmetry.

# Some singularities of this particular implementation include its inference of joins and its modeling of operators with asymmetric precedence. Joins are inferred when the parser does not expect
# to see a value but encounters one anyway. For instance, if you parse 'foo + bar bif', a join is inferred between 'bar' and 'bif' because after 'bar' the parser expected to encounter an
# operator, not a value. A join is also generated when you have a unary operator where a binary operator is expected. This causes the parser to do the right thing for expressions such as
# 'foo(bar)': a join is inferred after 'foo' and before '(bar)'.

# Unary operators have some strange precedence rules. All unary operators are prefix and therefore right-associative, and they cannot split anything to their left. For example, in 'foo + ! bif',
# no precedence of '!' can cause it to bind after the '+'. To deal with this, unary operators all have left-facing precedence 1 (higher than any other operator) and they have variable
# right-precedence. The right-precedence can be used to vary the scope of the binding: 'foo + -! bar / bif' causes the '!' to bind 'bar / bif', not just 'bar' as it normally would.

          precedence_table          = '\\. \\s # [~!] [/*] [%`] [-+] [\\\\:] [<>] [&?] \\^ = \\|'.qw *[new RegExp('^#{x}')] -seq,
          base_precedence(t)        = t === ',' ? 0x40000000 : t === ';' ? 0x40000001 : precedence_table |[x.test(t) && xi + 2] |seq,
          operator_lexer            = /^(\$*)([-\/\\|=]?)(.*)$/.qf,
          is_value                  = /^["'A-Za-z0-9@_\xff-\uffff]/.qf,
          is_unary(t)               = precedence_table[3].test(t) || !base_precedence(t),

          is_opener(t)              = '([{'.indexOf(t) + 1,
          is_closer(t)              = ')]}'.indexOf(t) + 1,

          parse_token(t)            = is_value(t)  ? {l: 0, r: 0,       id: t /!intern, v: true}                        : parse_operator(t),
          parse_operator(t)         = is_opener(t) ? {l: 0, r: 1 << 30, id: t /!intern, o: true, u: true, i: t === '('} :
                                      is_closer(t) ? {l: 0, r: 0,       id: t /!intern, c: true}                        : parse_regular_operator(t),

          parse_regular_operator(t) = {l: real_left, r: real_right, id: canonical /!intern, u: unary}
                              -where [pieces     = operator_lexer(t),
                                      adjust     = pieces[1].length << 2,
                                      canonical  = pieces[3] || pieces[2] || '#',
                                      left       = adjust + pieces[2] /!base_precedence /or [canonical /!base_precedence],
                                      right      = canonical.charAt(canonical.length - 1) /!base_precedence -re [it ? it + adjust : left],
                                      unary      = canonical /!is_unary,

                                      real_left  = unary ?    1 : left,
                                      real_right = unary ? left : right],

          join                      = '#' /!parse_operator,

          parse(ts)                 = ts *parse_token *!observe -seq -re- apply_all()
                              -where [values         = [],
                                      operators      = [],
                                      ev             = true,

                                      right(t)       = t.l & 1 || t.id === join.id && t.l > join.l,

                                      top()          = operators[operators.length - 1],
                                      precedence(t)  = apply() -then- precedence(t) -when [operators.length && (t /!right ? top().r < t.l : top().r <= t.l)],
                                      operator(t)    = precedence(t) -then- operators /~push/ t /then [ev = true] /unless [t.i],

                                      observe(t)     = t.v ? observe(join) /unless.ev -then [ev = false] -then- values /~push/ new syntax(t.id)
                                                     : t.o ? observe(join) /unless.ev -then [ev = true]  -then- operators /~push/ t
                                                     : t.c ? apply_closer()           -then [ev = false] -then [top().i ? operators.pop() : apply()]
                                                     : t.u ? observe(join) /unless.ev                    -then- operator(t)
                                                           : operator(t),

                                      apply()        = top().u ? values /~push/ new syntax(operators.pop().id, [values.pop()])
                                                               : values /~push/ new syntax(operators.pop().id, [y, x]) /where [x = values.pop(), y = values.pop()],
                                      apply_closer() = apply() -then- apply_closer() -unless [!operators.length || top().o],
                                      apply_all()    = operators.length ? apply() -then- apply_all() : values[values.length - 1]]]});

# Generated by SDoc 
