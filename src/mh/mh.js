caterwaul.module( 'mulholland.mh' ,function($) { (function() {var source_for=function(argv) {;
return(function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xr1=new xs1.constructor() ,xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] ,xr1.push( (read_file(x1) ) ) ;
return xr1} ) .call(this, (function(xs) {var x,x0,xi,xl,xr;
for(var xr=new xs.constructor() ,xi=0,xl=xs.length;
xi<xl;
 ++xi)x=xs[xi] , ( /^-/ .test(x) ) ||xr.push(x) ;
return xr} ) .call(this,argv) ) } ,modules_for=function(argv) {;
return(function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xr1=new xs1.constructor() ,xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] ,xr1.push( (read_file(x1) ) ) ;
return xr1} ) .call(this, (function(xs) {var x,x0,xi,xl,xr;
for(var xr=new xs.constructor() ,xi=0,xl=xs.length,y;
xi<xl;
 ++xi)x=xs[xi] , (y= ( /^-j/ .test(x) &&x.substr(2) ) ) &&xr.push(y) ;
return xr} ) .call(this,argv) ) } ,evaluate_js_modules=function(argv) {;
return(function() {var compile=$() ;
return(function(xs) {var x,x0,xi,xl,xr;
for(var xi=0,xl=xs.length;
xi<xl;
 ++xi)x=xs[xi] , (compile(new $.opaque_ref( ( '(function(){' + (x) + '})()' ) ) , {caterwaul:$,require:require} ) ) ;
return xs} ) .call(this,modules_for(argv) ) } ) .call(this) } ,contains_short=function(argv,o) {;
return(function() {var pattern=new RegExp( ( '^-(?!-)\\w*' + (o) + '' ) ) ;
return(function(xs) {var x,x0,xi,xl,xr;
for(var x=xs[0] ,xi=0,xl=xs.length,x2;
xi<xl;
 ++xi) {x=xs[xi] ;
if(x2= ( (pattern) .exec(x) ) )return x2}return false} ) .call(this,argv) } ) .call(this) } ,read_file=function(f) {;
return(function() {try{return require( 'fs' ) .readFileSync(f, 'utf8' ) }catch(e) {return f} } ) .call(this) } ,output=function(t) {;
return process.stdout.write(t+ ';\n' , 'utf8' ) } ,defaults= {cc:output} ;
return $.merge($.mulholland, (function() {var mh_main=function(argv) {;
return contains_short(argv, 'c' ) ?mh_compile(argv) :mh_repl(argv) } ,mh_compile=function(argv) {;
return(function() {var parser= (function(it) {return evaluate_js_modules(argv) ,it} ) .call(this, ($.mulholland() ) ) ,bundled_source=$.syntax.from_array( (function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xr1=new xs1.constructor() ,xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] ,xr1.push( ($.syntax.from_string(x1) ) ) ;
return xr1} ) .call(this, (function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xr1=new xs1.constructor() ,xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] ,xr1.push( (parser.sdoc(x1) ) ) ;
return xr1} ) .call(this,source_for(argv) ) ) ) ,resulting_tree=$.replicator() .toString() ,license= '// Mulholland compiler derivative | Spencer Tipping\n// Licensed under the terms of the MIT source code license' ,reference_url= ( '// Caterwaul modules: ' + (caterwaul.modules.join( " " ) ) + '\n// http://github.com/spencertipping/mulholland' ) ,header= ( '#!/usr/bin/env node\n' + (license) + '\n' + (reference_url) + '\n' ) ,footer= ( 'caterwaul.mulholland.mh_main(' + (bundled_source) + '.concat(process.argv.slice(2)));' ) ;
return output( ( '' + (header) + '\n' + (resulting_tree) + ';\n' + (footer) + '' ) ) } ) .call(this) } ,mh_repl=function(argv) {;
return(function() {var mh= (function(it) {return evaluate_js_modules(argv) ,it} ) .call(this, ($.mulholland.mh() ) ) ,evaluator=function(s,_1,_2,cc) {;
return(function() {var v=null;
return(function() {try{return mh(s, {cc:function(_) {return cc(null,v=_.as_js() .guarded() .toString() ) } } ) }catch(e) {return cc(e) } } ) .call(this) , !v&&cc(null,mh.context.toplevel.rules.length) } ) .call(this) } ;
return(function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] , (mh(x1) ) ;
return xs1} ) .call(this,source_for(argv) ) ,introduce() ,require( 'repl' ) .start( 'mh> ' ,undefined,evaluator) } ) .call(this) } ,context=function() {;
return{parse:$.mulholland() ,split:function(s) {;
return( (this) .parse(s) ) .flatten_all( ';' ) } ,environment:function() {;
return{c:$,context:this,parse:this.parse} } ,toplevel:$.mulholland.rewriter( [] ) } } ,introduce=function() {;
return process.stderr.write( 'Mulholland compiler (repl mode), copyright 2012 Spencer Tipping\n' + 'Licensed under the terms of the MIT source code license\n' + 'http://github.com/spencertipping/mulholland\n' ) } ,mh=function() {;
var result=function(s,specified_options) {;
return(function() {var options=$.merge( {} ,defaults,specified_options) ,evaluate=function(t) {var e=c.toplevel(t) ;
var d=e.resolved_data() ;
return d=== '!@' ?js_evaluate(e) :options.cc(e) } ,compiler=$( ':all' ) ,compile=function(tree) {;
return $.compile(compiler(tree) ,c.environment() ) } ,empty=c.parse.syntax(c.parse.intern( '@' ) ) ,js_evaluate=function(t) {;
return options.cc(compile(t[0] .as_js() .guarded() ) ||empty) } ;
return(function(xs1) {var x1,x01,xi1,xl1,xr1;
for(var xi1=0,xl1=xs1.length;
xi1<xl1;
 ++xi1)x1=xs1[xi1] , (evaluate(x1) ) ;
return xs1} ) .call(this,c.split(s) ) } ) .call(this) } ;
var c=result.context=context() ;
return result} ;
return{mh_main:mh_main,mh_compile:mh_compile,mh_repl:mh_repl,context:context,introduce:introduce,mh:mh} } ) .call(this) ) } ) .call(this) } ) ;
