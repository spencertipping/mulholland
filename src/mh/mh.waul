# Mulholland compiler runtime | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The Mulholland compiler runs or precompiles Mulholland source. It does this by applying rewrite rules to the source code, transforming the result into a Javascript expression using the
# as_caterwaul() method, and then either evaluating or serializing the tree. It provides a few builtin rewriting rules and compiler directives to bootstrap the process.

caterwaul.module('mulholland.mh', 'js_all', function ($) {

# Rewriting operators.
# Mulholland needs a way to trigger the initial rewriting pass, so it gives you the following toplevel rewrite rule: _x //@ [...] = rewriter(...)(_x). This says, "for every subtree of the form
# _x //@ [_y], rewrite _x using _y." This rewrite operator can be used to construct other rewrite operator forms; the syntax tree will be rewritten until it contains no more rewriting operators.
# At that point it is converted into Caterwaul and compiled or saved.

  $.mulholland.mh_main(argv) = argv.length ? argv *$.mulholland.mh *![console.log('%s', x.as_caterwaul().toString())] -seq : $.mulholland.mh_repl(),
  $.mulholland.mh_repl()     = require('repl').start('mh> ', undefined, evaluator) -where [evaluator(s, _1, _2, cc) = cc(null, '' + $.mulholland.mh(s).as_caterwaul()) -rescue- cc(e, undefined)],

  $.mulholland.mh(source) = source /!parse /!fixed_point_rewrite

  -where [parse                  = $.mulholland(),
          rewrite_form           = parse('_x //@ [_y]'),
          rewrite(match)         = $.mulholland.rewriter(match._y.flatten(',') *![x.data === '=' || new Error('#{match._x}: bad rewrite: #{match._y}') /raise] *[[x[0], x[1]]] -seq),

          toplevel_rewriter      = $.mulholland.rewriter([[rewrite_form, rewrite]]),
          fixed_point_rewrite(t) = t.first(rewrite_form) -re [it ? fixed_point_rewrite(toplevel_rewriter(it)) : t]]});

# Generated by SDoc 
