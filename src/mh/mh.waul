# Mulholland compiler runtime | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The Mulholland compiler runs or precompiles Mulholland source. It does this by applying rewrite rules to the source code, transforming the result into a Javascript expression using the
# as_js() method, and then either evaluating or serializing the tree. It provides a few builtin rewriting rules and compiler directives to bootstrap the process.

caterwaul.module('mulholland.mh', 'js_all', function ($) {

# Mulholland module format.
# Like waul, mh specifies a minimal toplevel execution context. This is used to define extensions that can be used later on. The toplevel gives you the following primitive operations:

# | 1. Global rewrite definition: foo = bar
#   2. Local anonymous rewrite: foo // (bar = bif)
#   3. Inline Javascript evaluation: @js! (x /function {_ /return x})

# Semantics.
# Mulholland goes to some lengths to make the global semantics sensible. In particular, no rewrite will have side-effects unless you evaluate a side-effecting Javascript expression somewhere,
# and you shouldn't do this. The reason purity is so important here is that Mulholland's rewriter tries to find the transitive closure of every expression it rewrites; so when you have an
# equation like 'foo = bar', even though no 'foo' exists at the moment, it is free to construct a 'foo' and test the rewrite rule to see whether it can inline something.

# All of this in mind, here is how Mulholland manages to provide a stateful interpreter and maintain a pure rewriter at the same time:

# | 1. Start with a blank toplevel rewriter.
#   2. For each global rewrite in the file, replace (!) the current toplevel rewriter with a new one that contains an additional rewriting rule.
#   3. For each toplevel thing that isn't a rewrite, emit its compiled output after rewriting.

# Each mh() function manages its own state by using a context object. This context object contains a parser and a rewriter, and the rewriter is updated for each global definition.

  $.mulholland /-$.merge/ wcapture [mh_main(argv)    = argv.length === 0 || argv /-contains_short/ 'i' ? argv /!mh_repl : argv /!mh_offline,

                                    mh_offline(argv) = source_for(argv) *!mh -seq -where [mh = $.mulholland.mh()],
                                    mh_repl(argv)    = source_for(argv) *!mh -seq -se- require('repl').start('mh> ', undefined, evaluator)
                                               -where [mh                       = $.mulholland.mh(),
                                                       evaluator(s, _1, _2, cc) = mh(s, {cc: "cc(null, v = _.toString())".qf}) -rescue- cc(e)
                                                                                  -se- cc(null, mh.context.toplevel.rules.length) /unless.v -where [v = null]],

                                    context()        = capture [parse    = $.mulholland(),
                                                                split(s) = this /~parse/ s /~flatten_all/ ';',
                                                                toplevel = [] /!$.mulholland.rewriter],

                                    mh(c = result.context = context())(s, options) = c.split(s) *!evaluate -seq
                                                                             -where [evaluate(t, e = c.toplevel(t)) = e.resolved_data() === '='  ? e /!define :
                                                                                                                      e.resolved_data() === '//' ? e /!rewrite /!evaluate : e /!cc,

                                                                                     cc(x)                          = (options -or- defaults) /~cc/ x,
                                                                                     rewrite(t)                     = c.toplevel.extend(t[1].flatten_all(';'))(t[0]),
                                                                                     define(equation)               = c.toplevel = c.toplevel /~extend/ [equation]]]

                            -where [options_for(argv)       = {verbose: contains_short(argv, 'v')},
                                    source_for(argv)        = argv %![/^-/.test(x)] *read_file -seq,
                                    contains_short(argv, o) = argv |[pattern /~exec/ x] |seq |where [pattern = new RegExp('^-(?!-)\\w*#{o}')],

                                    read_file(f)            = require('fs').readFileSync(f, 'utf8'),
                                    output(t)               = process.stdout.write(t + ';\n', 'utf8'),

                                    defaults                = {cc: output}]});

# Generated by SDoc 
