# Mulholland compiler runtime | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The Mulholland compiler runs or precompiles Mulholland source. It does this by applying rewrite rules to the source code, transforming the result into a Javascript expression using the
# as_caterwaul() method, and then either evaluating or serializing the tree. It provides a few builtin rewriting rules and compiler directives to bootstrap the process.

caterwaul.module('mulholland.mh', 'js_all', function ($) {

# Mulholland module format.
# Like waul, mh specifies a minimal toplevel execution context. This is used to define extensions that can be used later on. The toplevel gives you the following primitive operations:

# | 1. Global rewrite definition: foo =@ bar
#   2. Local anonymous rewrite: foo /@ (bar = bif)
#   3. Inline Javascript evaluation: @js! (x /function {_ /return x})

# Rewrites always apply outside-in, so you can use global rewrite definitions for abstraction. For example, if you write @foo _f =@ _f = x + 1 in one file and then write @foo g inside an
# anonymous rewrite in another file, @foo g will be expanded into g = x + 1 before the anonymous rewrite is executed. (This happens because anonymous rewrites pre-expand their rewriting
# contexts under the toplevel macroexpander.)

  $.mulholland.mh_main(argv) = !argv.length || argv /-contains_short/ 'i' ? $.mulholland.mh_repl(argv)
                                                                          : argv *read_file *mh *!output -seq -where [mh = $.mulholland.mh(options_for(argv))],

  $.mulholland.mh_repl(argv) = argv %![/^-/.test(x)] *read_file *!mh -seq -se- require('repl').start('mh> ', undefined, evaluator)
                       -where [mh                       = $.mulholland.mh(options_for(argv)),
                               evaluator(s, _1, _2, cc) = cc(null, mh(s).structure()) -rescue- cc(e, undefined)],

  $.mulholland.mh(options, options || (options = {})) = "parse(_).flatten_all(';') *top /seq -re- it.pop()".qf
                                             /-$.merge/ {define: define, rewrite: rewrite, compile: compile, parse: parse, output: output}

                                                -where [parse                = $.mulholland(),
                                                        blank                = parse('_'),
                                                        environment          = {caterwaul: $, require: require, parse: parse, define: define, rewrite: rewrite, compile: compile},
                                                        log_definition(p, r) = log('defining #{p} as #{r}')     -when- options.verbose,
                                                        log_compile(t, js)   = log('compiling #{t} into #{js}') -when- options.verbose,

                                                        define(match)        = (match._x /-log_definition/ match._y, top = top /~extend/ [[match._x, top(match._y)]], blank) -when.match,
                                                        rewrite(match)       = this.extend(top(match._y).flatten_all(';') *!check_rewrite -seq)(match._x)                    -when.match,
                                                        compile(match)       = new parse.syntax(blank.data)
                                                                               -se [log_compile(match._x, this(match._x) /~as_js/ parse),
                                                                                    it.replace = this(match._x) /~as_js/ parse /-$.compile/ environment]                     -when.match,

                                                        check_rewrite(tree)  = tree.resolved_data() === '=' || raise [new Error('/@: #{tree.structure()} is not a valid rewrite rule')],

                                                        top                  = $.mulholland.rewriter([[parse('@ (_x /@ _y)'), rewrite],
                                                                                                      [parse('@ (_x = _y)'),  define],
                                                                                                      [parse('@ (@js! _x)'),  compile]])],
  where [options_for(argv)       = {verbose: contains_short(argv, 'v')},
         contains_short(argv, o) = argv |[pattern /~exec/ x] |seq |where [pattern = new RegExp('^-(?!-)\\w*#{o}')],

         read_file(f)            = require('fs').readFileSync(f, 'utf8'),
         log(x)                  = process.stdout.write('\033[1;32mmh: \033[0;0m#{x}\n', 'utf8'),
         output(t)               = process.stdout.write(t.as_caterwaul().toString() + ';\n', 'utf8')]});

# Generated by SDoc 
