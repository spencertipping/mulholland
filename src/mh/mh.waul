# Mulholland compiler runtime | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The Mulholland compiler runs or precompiles Mulholland source. It does this by applying rewrite rules to the source code, transforming the result into a Javascript expression using the
# as_js() method, and then either evaluating or serializing the tree. It provides a few builtin rewriting rules and compiler directives to bootstrap the process.

caterwaul.module('mulholland.mh', 'js_all', function ($) {

# Mulholland module format.
# Like waul, mh specifies a minimal toplevel execution context. This is used to define extensions that can be used later on. The toplevel gives you the following primitive operations:

# | 1. Global rewrite definition: foo = bar
#   2. Local anonymous rewrite: foo // (bar = bif)
#   3. Inline Javascript evaluation: @js! (x /function {_ /return x})

# Semantics.
# Mulholland goes to some lengths to make the global semantics sensible. In particular, no rewrite will have side-effects unless you evaluate a side-effecting Javascript expression somewhere,
# and you shouldn't do this. The reason purity is so important here is that Mulholland's rewriter tries to find the transitive closure of every expression it rewrites; so when you have an
# equation like 'foo = bar', even though no 'foo' exists at the moment, it is free to construct a 'foo' and test the rewrite rule to see whether it can inline something.

# All of this in mind, here is how Mulholland manages to provide a stateful interpreter and maintain a pure rewriter at the same time:

# | 1. Start with a blank toplevel rewriter.
#   2. For each global rewrite in the file, replace (!) the current toplevel rewriter with a new one that contains an additional rewriting rule.
#   3. For each toplevel thing that isn't a rewrite, emit its compiled output after rewriting.

# Each mh() function manages its own state by using a context object. This context object contains a parser and a rewriter, and the rewriter is updated for each global definition.

# Command-line invocation.
# mh is designed to be used from the command line. The 'argv' passed into these functions is the list of net arguments; that is, no 'node' or 'mh'. You can get this from node by saying
# process.argv.slice(2); this eliminates node and the Javascript file. All options are parsed in short form; that is, a single dash. mh looks for these arguments:

# | -i  interactive mode: starts a REPL after loading all files
#   -r  compiles the given source output into Javascript statements and executes it immediately
#   -c  compiles a new 'mh' file with the given libraries bundled in and emits it to stdout

# For example:

# | $ mh -i foo.mh        # start a REPL after loading foo.mh
#   $ mh foo.mh           # compile foo.mh to Javascript and print result to stdout
#   $ mh -r foo.mh        # compile foo.mh to Javascript and execute it immediately

  $.mulholland /-$.merge/ wcapture [mh_main(argv)    = argv.length === 0 || argv /-contains_short/ 'i' ? argv /!mh_repl :
                                                                            argv /-contains_short/ 'c' ? argv /!mh_compile : argv /!mh_offline,

                                    mh_compile(argv) = '#{header}\n#{resulting_tree}\n#{footer}' /!output
                                               -where [bundled_source = $.syntax.from_array(source_for(argv) *$.syntax.from_string -seq),
                                                       resulting_tree = $.replicator().toString(),
                                                       header         = '#!/usr/bin/env node',
                                                       footer         = 'caterwaul.mulholland.mh_main(#{bundled_source}.concat(process.argv.slice(2)));'],

                                    mh_offline(argv) = source_for(argv) *!mhc -seq
                                               -where [mh          = $.mulholland.mh(),
                                                       cc          = argv /-contains_short/ 'r' ? "_.as_js() /-$.compile/ environment".qf : "_.as_js().toString() /!output".qf,
                                                       environment = {c: $, mh: mh, require: require, process: process},
                                                       mhc(t)      = mh(t, {cc: cc})],

                                    mh_repl(argv)    = source_for(argv) *!mh -seq -se- require('repl').start('mh> ', undefined, evaluator)
                                               -where [mh                       = $.mulholland.mh(),
                                                       evaluator(s, _1, _2, cc) = mh(s, {cc: "cc(null, v = _.toString())".qf}) -rescue- cc(e)
                                                                                  -se- cc(null, mh.context.toplevel.rules.length) /unless.v -where [v = null]],

                                    context()        = capture [parse    = $.mulholland(),
                                                                split(s) = this /~parse/ s /~flatten_all/ ';',
                                                                toplevel = [] /!$.mulholland.rewriter],

                                    mh(c = result.context = context())(s, options) = c.split(s) *!evaluate -seq
                                                                             -where [evaluate(t, e = c.toplevel(t)) = e.resolved_data() === '='  ? e /!define :
                                                                                                                      e.resolved_data() === '//' ? e /!rewrite /!evaluate : e /!cc,

                                                                                     cc(x)                          = (options -or- defaults) /~cc/ x,
                                                                                     rewrite(t)                     = c.toplevel.extend(t[1].flatten_all(';'))(t[0]),
                                                                                     define(equation)               = c.toplevel = c.toplevel /~extend/ [equation]]]

                            -where [source_for(argv)        = argv %![/^-/.test(x)] *read_file -seq,
                                    contains_short(argv, o) = argv |[pattern /~exec/ x] |seq |where [pattern = new RegExp('^-(?!-)\\w*#{o}')],

                                    read_file(f)            = require('fs').readFileSync(f, 'utf8') -rescue- f,
                                    output(t)               = process.stdout.write(t + ';\n', 'utf8'),

                                    defaults                = {cc: output}]});

# Generated by SDoc 
