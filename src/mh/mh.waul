# Mulholland compiler runtime | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# The Mulholland compiler runs or precompiles Mulholland source. It does this by applying rewrite rules to the source code, transforming the result into a Javascript expression using the
# as_caterwaul() method, and then either evaluating or serializing the tree. It provides a few builtin rewriting rules and compiler directives to bootstrap the process.

caterwaul.module('mulholland.mh', 'js_all', function ($) {

# Mulholland module format.
# Like waul, mh specifies a minimal toplevel execution context. This is used to define extensions that can be used later on. The toplevel gives you the following primitive operations:

# | 1. Global rewrite definition: foo =@ bar
#   2. Local anonymous rewrite: foo /@ (bar = bif)
#   3. Inline Javascript evaluation: @js (x -> x + 1)

# Rewrites always apply outside-in, so you can use global rewrite definitions for abstraction. For example, if you write @foo _f =@ _f = x + 1 in one file and then write @foo g inside an
# anonymous rewrite in another file, @foo g will be expanded into g = x + 1 before the anonymous rewrite is executed. (This happens because anonymous rewrites pre-expand their rewriting
# contexts under the toplevel macroexpander.)

  $.mulholland.mh_main(argv) = argv.length && argv |![x === '-i'] |seq ? argv *read_file *mh *!output -seq -where [mh = $.mulholland.mh()] : $.mulholland.mh_repl(argv),
  $.mulholland.mh_repl(argv) = argv %![/^-/.test(x)] *read_file *!mh -seq -se- require('repl').start('mh> ', undefined, evaluator)
                       -where [mh                       = $.mulholland.mh(),
                               evaluator(s, _1, _2, cc) = cc(null, mh(s).structure()) -rescue- cc(e, undefined)],

  $.mulholland.mh() = "parse(_).flatten_all(';') *toplevel_rewriter -seq -re- it.pop()".qf /-$.merge/ {define: define, rewrite: rewrite, compile: compile, parse: parse, js: js, output: output}

  -where [parse     = $.mulholland(),          define(match)  = match && (toplevel_rewriter = toplevel_rewriter /~extend/ [[match._x, toplevel_rewriter(match._y)]]) -re- blank,
          js        = $.mulholland.js(parse),  rewrite(match) = match && toplevel_rewriter.extend(toplevel_rewriter(match._y).flatten_all(','))(match._x),
          blank     = parse('_'),              compile(match) = match && match._x -se [it.replace(m) = f(m)] -where [f = js(toplevel_rewriter(match._x)) /!$.compile],

          toplevel_rewriter = $.mulholland.rewriter([[parse('_x /@ _y'), rewrite], [parse('_x =@ _y'), define], [parse('@js! _x'), compile]])],

  where [read_file(f) = require('fs').readFileSync(f, 'utf8'),
         output(t)    = process.stdout.write(t.as_caterwaul().toString() + ';\n', 'utf8')]});

# Generated by SDoc 
