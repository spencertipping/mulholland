\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}

\lstnewenvironment{resourcecode}{}{}

\title{Mulholland reference}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}

\chapter{Introduction}
  Mulholland is a term-rewriting language that arose from the idea that abstractions should be erased at compile-time as an optimization measure. Unlike a lot of languages that do this,
  Mulholland enables the compiler to perform representation abstraction; that is, the data structures and function calls modeled in source code may be completely changed in the compiled
  result.

  Caterwaul has the ability to do things like this, but it has other shortcomings:

\begin{enumerate}
\item{Its broad interoperation with Javascript means that it is difficult to port to non-JS runtimes.}
\item{It generates unreadable output that makes debugging difficult.}
\item{Rewriting uses no static analysis and therefore is quite slow.}
\item{Rewriting is assumed to be tree-homomorphic (as is Lisp rewriting).}
\item{Its syntax trees are lower-level than is generally useful.}
\end{enumerate}

  Mulholland is, structurally, an infix Lisp with polymorphic consing. Operators have well-defined precedence based purely on their syntactic characteristics. Contexts are used to encapsulate
  the rewriting process; this allows you to use destructuring binds to create rewrites. Tree-homomorphism is partial and explicitly specified, not tacitly assumed and universal as it is in
  Lisp's macro system.

\chapter{Polymorphic consing}
  Lisp's cons cells have two variables, their {\tt car} and their {\tt cdr}. Generally this is used to form trees where the {\tt car} is used to indicate the role of the {\tt cdr}; for
  example, the list {\tt (foo bar bif)} is interpreted as a function or macro call to {\tt foo}. The cons cells themselves are transparent to this process.

  Generally this works well. There are a few cases where, I think, it makes less sense, including arithmetic expressions. For this case, I think using the {\tt car} to encode the operation is
  somewhat strange and indirect; better, in my opinion, is to use a different cons operator in the first place. Structurally, Lisp and Mulholland differ in this respect:

\begin{verbatim}
;; Lisp: monomorphic cons, polymorphism is implied and encoded
;; in the head of the list
(cons '+ (cons 3 (cons 4 nil)))

;; Mulholland: polymorphic cons, polymorphism is universal and
;; encoded as a variant of the cons itself
(cons-+ 3 4)
\end{verbatim}

  Another significant difference here is that Lisp uses well-formed lists and Mulholland does not. There's a good reason for this having to do with list homomorphism. In Lisp, macros are
  invoked by the {\tt car} of a list, meaning that {\tt (foo)} and {\tt ((foo))} mean two different things. The only reason these lists differ is that each layer of parentheses creates a
  nontrivial element consed to a trivial {\tt nil}.

\section{List homomorphisms in Lisp}
    There are a couple of things worth noting about Lisp's approach. First, all intent is left-focused; each cons cell's purpose is dictated by its {\tt car}, rarely by its {\tt cdr}. This is
    baked into the macroexpander, and it is often used as a convention in Lisp libraries. Second, perhaps more interestingly, list homomorphism and evaluation have these equations, where
    $M[x]$ represents the macroexpansion transformation and $E[x]$ represents evaluation:
\begin{align*}
E[x:y]      & = E[x](E'[y]) \\
E'[(x:y):z] & = E[x:y]:E'[z] \\
M[x:y]      & = \begin{cases}
                  x(y)    & \textrm{$x$ is a defined macro} \\
                  x:M'[y] & \textrm{otherwise}
                \end{cases} \\
M'[(x:y):z] & = M[x:y]:M'[z]
\end{align*}

    There are two interesting differences between $E$ and $M$. First, $E$ evaluates lists from the inside out; by the time the function call happens, all of its arguments have been evaluated.
    This means that evaluation is (nominally) transparent across function arguments, an interpretation that allows arguments to be forced prior to the invocation. Second, the {\tt car} is
    recursively evaluated under $E$ but not under $M$.

    Macro bodies have a predictable evaluation scheme:
\begin{align*}
E[(\texttt{defmacro}:name:formals:body:\texttt{nil})] & \Rightarrow (name \rightarrow E[body])
\end{align*}

    This is crucial; it effectively provides $body$ with a way to use $M$.

\section{Tree homomorphism in Mulholland}
    

\chapter{Contexts}\label{sec:contexts}

\end{document}
