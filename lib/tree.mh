Mulholland syntax tree reflection | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Mulholland's pattern matching API is good for high-level declarative specification, but it has properties that make it less versatile than is often useful. For example, there isn't a way to
get a wildcard to bind to a binary operator. If you want to do this, you'll need to use tree reflection to construct operator trees up-front. This library gives you a reasonable way to do
that.

@! (mulholland = mulholland || {});

_x.@group = '('.@unquote.@cons1 _x;
_x.@new = 'new'.@unquote.@cons1 _x;

_x $ _y = _x _y;

_x@0.@unquote =@ parse.syntax $ parse.intern $ (match._x.resolved_data @).replace ("/^'(.*)'$/"r, '$1');
_x@0.@quote   =@ parse.syntax $ parse.intern $ "'" + match._x.resolved_data @ + "'";

_x@0.@cons1 _y       =@ parse.syntax (match._x.data, [match._y]);
_x@0.@cons2 _y _z    =@ parse.syntax (match._x.data, [match._y, match._z]);
_x@0.@cons3 _y _z _t =@ parse.syntax (match._x.data, [match._y, match._z, match._t])

Syntax node folding.

#_x@0.@/il = _x :: @nil; (_op.@cons2 _x _y).@/il = 
